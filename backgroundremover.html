<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Background Remover by Uzair B2B Services</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add TensorFlow.js and the BodyPix model for automatic removal -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0/dist/body-pix.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            text-align: center;
        }

        #canvas-container {
            position: relative;
            background-color: #e5e7eb;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px dashed #9ca3af;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
            margin-top: 1.5rem;
        }

        #image-canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: pointer;
            border-radius: 1rem;
        }

        /* Brush cursor style */
        #image-canvas.manual-mode {
            cursor: crosshair;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
        }

        .btn-primary {
            background-color: #2563eb;
            color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .btn-primary:hover {
            background-color: #1d4ed8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: #6b7280;
            color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .btn-secondary:hover {
            background-color: #4b5563;
            transform: translateY(-2px);
        }

        .btn.active {
            background-color: #1d4ed8;
            color: #ffffff;
        }

        .message-box {
            background-color: #d1fae5;
            color: #065f46;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        
        .message-box.show {
            opacity: 1;
        }

        .hidden {
            display: none;
        }

        /* Styles for the loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #ffffff;
            animation: spin 1s ease infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="p-8">
    <div class="container">
        <div class="card">
            <h1 class="text-3xl sm:text-4xl font-extrabold mb-4 text-gray-800">UZAIR B2B A.I. (Background Remover)</h1>
            <p class="text-gray-600 mb-6">Upload an image and choose a removal method.</p>

            <div id="message-box" class="message-box hidden"></div>

            <div class="flex flex-col sm:flex-row items-center justify-center sm:space-x-4 space-y-4 sm:space-y-0 flex-wrap">
                <label for="image-upload" class="cursor-pointer">
                    <div class="btn btn-primary">
                        Upload Image
                    </div>
                    <input type="file" id="image-upload" accept="image/*" class="hidden">
                </label>
                <button id="automatic-remove-btn" class="btn btn-primary flex items-center hidden">
                    <span id="auto-btn-text">Automatic Remove</span>
                    <div id="auto-btn-spinner" class="spinner ml-2 hidden"></div>
                </button>
                <button id="magic-wand-btn" class="btn btn-secondary flex items-center hidden">
                    Magic Wand
                </button>
                <button id="magic-repair-btn" class="btn btn-secondary flex items-center hidden">
                    Magic Repair
                </button>
                <button id="manual-remove-btn" class="btn btn-secondary flex items-center hidden">
                    Manual Remove
                </button>
                <button id="manual-repair-btn" class="btn btn-secondary flex items-center hidden">
                    Manual Repair
                </button>
                <button id="download-btn" class="btn btn-secondary hidden">Download Image</button>
            </div>
            
            <div id="manual-controls" class="flex flex-col sm:flex-row items-center justify-center sm:space-x-2 mt-4 hidden">
                <span class="text-gray-600">Brush Size:</span>
                <input type="range" id="brush-size-slider" min="5" max="100" value="30" class="w-full sm:w-32">
                <span id="brush-size-display">30</span>
            </div>

            <div id="canvas-container" class="mt-6">
                <span class="text-gray-500 text-lg">Your image will appear here.</span>
                <canvas id="image-canvas" class="hidden"></canvas>
            </div>
        </div>
    </div>
    
    <footer class="mt-8 text-center text-gray-500 text-sm">
        Made by uzair b2b services
    </footer>

    <script>
        // Get DOM elements
        const imageUpload = document.getElementById('image-upload');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('image-canvas');
        const downloadBtn = document.getElementById('download-btn');
        const automaticRemoveBtn = document.getElementById('automatic-remove-btn');
        const magicWandBtn = document.getElementById('magic-wand-btn');
        const magicRepairBtn = document.getElementById('magic-repair-btn');
        const manualRemoveBtn = document.getElementById('manual-remove-btn');
        const manualRepairBtn = document.getElementById('manual-repair-btn');
        const manualControls = document.getElementById('manual-controls');
        const brushSizeSlider = document.getElementById('brush-size-slider');
        const brushSizeDisplay = document.getElementById('brush-size-display');
        const autoBtnText = document.getElementById('auto-btn-text');
        const autoBtnSpinner = document.getElementById('auto-btn-spinner');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const messageBox = document.getElementById('message-box');

        let originalImage = new Image();
        let imageData = null;
        let originalImageData = null; // Store original image data for magic repair
        let model = null;
        let currentMode = 'magic-wand'; // New state variable for current mode
        let isDrawing = false;
        let lastPos = { x: 0, y: 0 };
        let brushSize = parseInt(brushSizeSlider.value);

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('success' or 'error').
         */
        const showMessage = (message, type) => {
            messageBox.textContent = message;
            messageBox.className = `message-box show`;
            if (type === 'success') {
                messageBox.style.backgroundColor = '#d1fae5';
                messageBox.style.color = '#065f46';
            } else if (type === 'error') {
                messageBox.style.backgroundColor = '#fee2e2';
                messageBox.style.color = '#991b1b';
            }
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        };

        /**
         * Loads the BodyPix model.
         */
        const loadModel = async () => {
            if (!model) {
                showMessage('Loading automatic removal model...', 'success');
                try {
                    model = await bodyPix.load();
                    showMessage('Model loaded successfully!', 'success');
                } catch (e) {
                    showMessage('Failed to load model. Automatic removal will not work.', 'error');
                }
            }
        };

        // Load the model as soon as the page is ready
        loadModel();

        /**
         * Handles the image file upload event.
         * @param {Event} event - The file input change event.
         */
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        /**
         * Handles the image loading and drawing on the canvas.
         */
        originalImage.onload = () => {
            // Display the canvas and primary button
            canvasContainer.querySelector('span').classList.add('hidden');
            canvas.classList.remove('hidden');
            automaticRemoveBtn.classList.remove('hidden');
            downloadBtn.classList.remove('hidden');

            // Hide the other buttons and controls initially
            magicWandBtn.classList.add('hidden');
            magicRepairBtn.classList.add('hidden');
            manualRemoveBtn.classList.add('hidden');
            manualRepairBtn.classList.add('hidden');
            manualControls.classList.add('hidden');

            // Set canvas dimensions to match the image
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // CRITICAL FIX: Clear the canvas to ensure a transparent background
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the image onto the canvas
            ctx.drawImage(originalImage, 0, 0);
            
            // Get the image data for pixel manipulation and store the original
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            showMessage('Image uploaded! Click "Automatic Remove" to begin.', 'success');
            
            // Set default mode to magic wand
            toggleMode('magic-wand');
        };

        /**
         * Calculates the color distance (Euclidean distance in RGB space) between two colors.
         * @param {number[]} color1 - An array of [R, G, B] values.
         * @param {number[]} color2 - An array of [R, G, B] values.
         * @returns {number} The distance between the colors.
         */
        const colorDistance = (color1, color2) => {
            return Math.sqrt(
                Math.pow(color1[0] - color2[0], 2) +
                Math.pow(color1[1] - color2[1], 2) +
                Math.pow(color1[2] - color2[2], 2)
            );
        };

        /**
         * A basic "magic wand" tool that makes similar colors transparent.
         * @param {number} x - The x-coordinate of the clicked pixel.
         * @param {number} y - The y-coordinate of the clicked pixel.
         * @param {number} tolerance - The color tolerance (0-255). Lower is more precise.
         */
        const magicWand = (x, y, tolerance) => {
            if (!imageData) {
                showMessage('Please upload an image first.', 'error');
                return;
            }

            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;

            // Get the color of the clicked pixel
            const pixelIndex = (y * width + x) * 4;
            const targetColor = [pixels[pixelIndex], pixels[pixelIndex + 1], pixels[pixelIndex + 2]];

            // Use a stack to perform a flood fill operation
            const stack = [[x, y]];
            const visited = new Set();

            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const currentPixelIndex = (cy * width + cx) * 4;

                // Check bounds and if pixel has been visited
                if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited.has(`${cx},${cy}`)) {
                    continue;
                }
                visited.add(`${cx},${cy}`);

                const currentColor = [pixels[currentPixelIndex], pixels[currentPixelIndex + 1], pixels[currentPixelIndex + 2]];

                // If the color is within the tolerance, make it transparent
                if (colorDistance(targetColor, currentColor) <= tolerance) {
                    pixels[currentPixelIndex + 3] = 0; // Set alpha to 0 (transparent)

                    // Push neighboring pixels to the stack
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            // Update the canvas with the new image data
            ctx.putImageData(imageData, 0, 0);
            showMessage('Background removed! Click another area or download.', 'success');
        };

        /**
         * The "Magic Repair" tool that restores the original background from a transparent area.
         * @param {number} x - The x-coordinate of the clicked pixel.
         * @param {number} y - The y-coordinate of the clicked pixel.
         */
        const magicRepair = (x, y) => {
            if (!imageData || !originalImageData) {
                showMessage('Please upload an image first.', 'error');
                return;
            }

            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;
            const originalPixels = originalImageData.data;

            // Check if the clicked pixel is already opaque. If so, nothing to repair.
            const pixelIndex = (y * width + x) * 4;
            if (pixels[pixelIndex + 3] !== 0) {
                showMessage('This area is not transparent.', 'error');
                return;
            }

            const stack = [[x, y]];
            const visited = new Set();

            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const currentPixelIndex = (cy * width + cx) * 4;

                if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited.has(`${cx},${cy}`)) {
                    continue;
                }
                visited.add(`${cx},${cy}`);

                // If the pixel is transparent, restore it from the original image data
                if (pixels[currentPixelIndex + 3] === 0) {
                    pixels[currentPixelIndex] = originalPixels[currentPixelIndex];
                    pixels[currentPixelIndex + 1] = originalPixels[currentPixelIndex + 1];
                    pixels[currentPixelIndex + 2] = originalPixels[currentPixelIndex + 2];
                    pixels[currentPixelIndex + 3] = 255; // Set alpha to 255 (opaque)

                    // Push neighboring pixels to the stack to continue the fill
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            ctx.putImageData(imageData, 0, 0);
            showMessage('Background restored!', 'success');
        };

        /**
         * Toggles between different editing modes.
         * @param {string} mode - 'magic-wand', 'magic-repair', 'manual-remove', or 'manual-repair'.
         */
        const toggleMode = (mode) => {
            currentMode = mode;
            const isManualMode = (currentMode === 'manual-remove' || currentMode === 'manual-repair');

            // Update button styles
            magicWandBtn.classList.remove('active');
            magicRepairBtn.classList.remove('active');
            manualRemoveBtn.classList.remove('active');
            manualRepairBtn.classList.remove('active');
            
            if (mode === 'magic-wand') {
                magicWandBtn.classList.add('active');
            } else if (mode === 'magic-repair') {
                magicRepairBtn.classList.add('active');
            } else if (mode === 'manual-remove') {
                manualRemoveBtn.classList.add('active');
            } else if (mode === 'manual-repair') {
                manualRepairBtn.classList.add('active');
            }

            // Show/hide manual controls
            if (isManualMode) {
                manualControls.classList.remove('hidden');
                canvas.classList.add('manual-mode');
            } else {
                manualControls.classList.add('hidden');
                canvas.classList.remove('manual-mode');
            }

            showMessage(`Switched to ${mode} mode.`, 'success');
        };

        magicWandBtn.addEventListener('click', () => toggleMode('magic-wand'));
        magicRepairBtn.addEventListener('click', () => toggleMode('magic-repair'));
        manualRemoveBtn.addEventListener('click', () => toggleMode('manual-remove'));
        manualRepairBtn.addEventListener('click', () => toggleMode('manual-repair'));

        /**
         * Handles the canvas click event to activate the tools.
         * @param {Event} event - The mouse click event.
         */
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((event.clientX - rect.left) * scaleX);
            const y = Math.floor((event.clientY - rect.top) * scaleY);
            
            if (currentMode === 'magic-wand') {
                magicWand(x, y, 32); 
            } else if (currentMode === 'magic-repair') {
                magicRepair(x, y);
            }
        });

        // Event listeners for the manual brush
        canvas.addEventListener('mousedown', (e) => {
            if (currentMode !== 'manual-remove' && currentMode !== 'manual-repair') return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastPos = { 
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const newPos = { 
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
            
            if (currentMode === 'manual-remove') {
                // Set the drawing mode to 'destination-out' to make pixels transparent
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(newPos.x, newPos.y, brushSize / 2, 0, Math.PI * 2, false);
                ctx.fill();
            } else if (currentMode === 'manual-repair') {
                // Set the drawing mode to 'source-over' to draw on top
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw a circular portion of the original image onto the current canvas
                // This is a simple but effective way to "repair" the transparency
                ctx.drawImage(
                    originalImage,
                    newPos.x - brushSize / 2,
                    newPos.y - brushSize / 2,
                    brushSize,
                    brushSize,
                    newPos.x - brushSize / 2,
                    newPos.y - brushSize / 2,
                    brushSize,
                    brushSize
                );
            }

            lastPos = newPos;
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Update brush size when the slider changes
        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeDisplay.textContent = brushSize;
        });

        /**
         * Handles the automatic background removal using BodyPix.
         */
        automaticRemoveBtn.addEventListener('click', async () => {
            if (!originalImage.src) {
                showMessage('Please upload an image first.', 'error');
                return;
            }
            if (!model) {
                 showMessage('Model is still loading, please wait.', 'error');
                return;
            }

            // Show loading state
            automaticRemoveBtn.disabled = true;
            autoBtnText.textContent = 'Processing...';
            autoBtnSpinner.classList.remove('hidden');
            showMessage('Processing... this may take a moment.', 'success');

            // Defer the heavy processing to allow the UI to update first
            setTimeout(async () => {
                try {
                    // Get the segmentation mask from the BodyPix model
                    const segmentation = await model.segmentPerson(originalImage, {
                        flipHorizontal: false,
                        internalResolution: 'high',
                        segmentationThreshold: 0.7,
                    });

                    // Get the image data to modify the pixels
                    const newImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = newImageData.data;

                    // Iterate over each pixel and set the alpha to 0 if it's not part of the person
                    for (let i = 0; i < segmentation.data.length; i++) {
                        if (segmentation.data[i] === 0) { // 0 means background
                            data[i * 4 + 3] = 0; // Set alpha channel to 0
                        }
                    }
                    
                    // Put the modified image data back on the canvas
                    ctx.putImageData(newImageData, 0, 0);
                    imageData = newImageData; // Update the main imageData variable

                    // After automatic removal, show the manual tools for touch-ups
                    magicWandBtn.classList.remove('hidden');
                    magicRepairBtn.classList.remove('hidden');
                    manualRemoveBtn.classList.remove('hidden');
                    manualRepairBtn.classList.remove('hidden');

                    showMessage('Automatic background removal complete! Use the other tools for touch-ups if needed.', 'success');
                } catch (error) {
                    showMessage('Error during automatic removal. Please try again.', 'error');
                    console.error('BodyPix segmentation error:', error);
                } finally {
                    // Hide loading state
                    automaticRemoveBtn.disabled = false;
                    autoBtnText.textContent = 'Automatic Remove';
                    autoBtnSpinner.classList.add('hidden');
                }
            }, 0);
        });

        /**
         * Handles the download button click event.
         */
        downloadBtn.addEventListener('click', () => {
            // Check if there is an image to download
            if (!imageData) {
                showMessage('No image to download.', 'error');
                return;
            }

            // Create a temporary link element
            const link = document.createElement('a');
            link.download = 'removed_background.png';

            // Convert the canvas content to a PNG image data URL
            link.href = canvas.toDataURL('image/png');

            // Append the link to the body and click it to trigger the download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('Image downloaded!', 'success');
        });
    </script>
</body>
</html>
