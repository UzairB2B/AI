<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background.AI - Free Background Remover</title>
    <!-- Font link for Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- CDN for Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add TensorFlow.js and the BodyPix model for automatic removal -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0/dist/body-pix.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Brush cursor style for manual editing */
        .manual-mode {
            cursor: crosshair;
        }

        /* Styles for the loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border-left-color: #fff;
            animation: spin 1s ease infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased min-h-screen flex flex-col items-center justify-center">

    <!-- Main App Container -->
    <div id="app" class="flex flex-col flex-grow w-full max-w-5xl mx-auto rounded-xl shadow-lg overflow-hidden bg-white mt-6 mb-6 md:mt-12 md:mb-6">

        <!-- Header -->
        <div class="flex items-center justify-between p-4 sm:p-6 border-b border-gray-200 flex-wrap">
            <h1 class="text-xl sm:text-3xl font-extrabold text-gray-900 mb-2 sm:mb-0">VANISHER AI</h1>
            <div class="flex items-center space-x-2">
                <!-- Home Button -->
                <a href="index.html" class="px-3 py-1 sm:px-4 sm:py-2 bg-gray-200 text-gray-700 rounded-full text-sm font-semibold shadow-md hover:bg-gray-300 transition-colors duration-200 flex items-center">
                    <i class="fas fa-home mr-2"></i>
                    Home
                </a>
                <p class="text-xs sm:text-sm text-gray-500">
                    Made by
                    <span class="text-blue-600">uzair b2b services</span>
                </p>
            </div>
        </div>

        <!-- Main Content -->
        <div class="p-6 flex flex-col flex-grow w-full">
            <p class="text-gray-600 mb-6 text-center">Upload an image and choose a removal method.</p>

            <!-- Message Box -->
            <div id="message-box" class="hidden rounded-xl px-4 py-2 text-center text-sm font-medium mb-4"></div>

            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-x-4 sm:space-y-0 flex-wrap mb-6">
                <!-- Upload Button -->
                <label for="image-upload" class="cursor-pointer">
                    <div class="px-6 py-3 rounded-full bg-blue-600 text-white font-semibold shadow-md hover:bg-blue-700 transition-colors duration-200 flex items-center">
                        <i class="fas fa-upload mr-2"></i>
                        Upload Image
                    </div>
                    <input type="file" id="image-upload" accept="image/*" class="hidden">
                </label>

                <!-- Action Buttons (Initially Hidden) -->
                <button id="automatic-remove-btn" class="hidden px-6 py-3 rounded-full bg-blue-600 text-white font-semibold shadow-md hover:bg-blue-700 transition-colors duration-200 flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                    <span id="auto-btn-text">Automatic Remove</span>
                    <div id="auto-btn-spinner" class="spinner ml-2 hidden"></div>
                </button>
                <button id="magic-wand-btn" class="hidden px-6 py-3 rounded-full bg-gray-200 text-gray-700 font-semibold shadow-md hover:bg-gray-300 transition-colors duration-200">
                    Magic Wand
                </button>
                <button id="magic-repair-btn" class="hidden px-6 py-3 rounded-full bg-gray-200 text-gray-700 font-semibold shadow-md hover:bg-gray-300 transition-colors duration-200">
                    Magic Repair
                </button>
                <button id="manual-remove-btn" class="hidden px-6 py-3 rounded-full bg-gray-200 text-gray-700 font-semibold shadow-md hover:bg-gray-300 transition-colors duration-200">
                    Manual Remove
                </button>
                <button id="manual-repair-btn" class="hidden px-6 py-3 rounded-full bg-gray-200 text-gray-700 font-semibold shadow-md hover:bg-gray-300 transition-colors duration-200">
                    Manual Repair
                </button>
                <button id="download-btn" class="hidden px-6 py-3 rounded-full bg-blue-600 text-white font-semibold shadow-md hover:bg-blue-700 transition-colors duration-200">
                    <i class="fas fa-download mr-2"></i>
                    Download Image
                </button>
            </div>
            
            <!-- Manual Brush Controls (Initially Hidden) -->
            <div id="manual-controls" class="hidden flex items-center justify-center space-x-4 mb-4">
                <span class="text-gray-600 font-medium">Brush Size:</span>
                <input type="range" id="brush-size-slider" min="5" max="100" value="30" class="w-full sm:w-32 accent-blue-600">
                <span id="brush-size-display" class="text-gray-700 font-semibold">30</span>
            </div>

            <!-- Canvas Container -->
            <div id="canvas-container" class="relative bg-gray-200 rounded-xl overflow-hidden border-4 border-dashed border-gray-400 min-h-[400px] flex items-center justify-center">
                <span id="canvas-placeholder" class="text-gray-500 text-lg">Your image will appear here.</span>
                <canvas id="image-canvas" class="hidden"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="mt-auto text-center text-gray-500 text-sm py-4">
        Made by uzair b2b services
    </footer>

    <script>
        // Get DOM elements
        const imageUpload = document.getElementById('image-upload');
        const canvasContainer = document.getElementById('canvas-container');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const canvas = document.getElementById('image-canvas');
        const downloadBtn = document.getElementById('download-btn');
        const automaticRemoveBtn = document.getElementById('automatic-remove-btn');
        const magicWandBtn = document.getElementById('magic-wand-btn');
        const magicRepairBtn = document.getElementById('magic-repair-btn');
        const manualRemoveBtn = document.getElementById('manual-remove-btn');
        const manualRepairBtn = document.getElementById('manual-repair-btn');
        const manualControls = document.getElementById('manual-controls');
        const brushSizeSlider = document.getElementById('brush-size-slider');
        const brushSizeDisplay = document.getElementById('brush-size-display');
        const autoBtnText = document.getElementById('auto-btn-text');
        const autoBtnSpinner = document.getElementById('auto-btn-spinner');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const messageBox = document.getElementById('message-box');

        let originalImage = new Image();
        let imageData = null;
        let originalImageData = null;
        let model = null;
        let currentMode = '';
        let isDrawing = false;
        let lastPos = { x: 0, y: 0 };
        let brushSize = parseInt(brushSizeSlider.value);

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('success' or 'error').
         */
        const showMessage = (message, type) => {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'bg-red-200', 'text-red-800', 'bg-blue-200', 'text-blue-800');
            if (type === 'success') {
                messageBox.classList.add('bg-blue-200', 'text-blue-800');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-200', 'text-red-800');
            }
            // Temporarily show the message and then hide it after a delay
            messageBox.style.opacity = '1';
            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.classList.add('hidden');
            }, 5000);
        };

        /**
         * Loads the BodyPix model asynchronously.
         */
        const loadModel = async () => {
            if (!model) {
                showMessage('Loading automatic removal model...', 'success');
                try {
                    model = await bodyPix.load();
                    showMessage('Model loaded successfully!', 'success');
                } catch (e) {
                    showMessage('Failed to load model. Automatic removal will not work.', 'error');
                }
            }
        };

        // Load the model as soon as the page is ready
        loadModel();

        /**
         * Handles the image file upload event.
         */
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        /**
         * Handles the image loading and drawing on the canvas.
         */
        originalImage.onload = () => {
            // Display the canvas and primary button
            canvasPlaceholder.classList.add('hidden');
            canvas.classList.remove('hidden');
            automaticRemoveBtn.classList.remove('hidden');
            downloadBtn.classList.remove('hidden');

            // Hide the other buttons and controls initially
            magicWandBtn.classList.add('hidden');
            magicRepairBtn.classList.add('hidden');
            manualRemoveBtn.classList.add('hidden');
            manualRepairBtn.classList.add('hidden');
            manualControls.classList.add('hidden');

            // Set canvas dimensions to match the image
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // Clear the canvas to ensure a transparent background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw the image onto the canvas
            ctx.drawImage(originalImage, 0, 0);
            
            // Get the image data for pixel manipulation and store the original
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            showMessage('Image uploaded! Click "Automatic Remove" to begin.', 'success');
        };

        /**
         * Calculates the color distance (Euclidean distance in RGB space) between two colors.
         * @param {number[]} color1 - An array of [R, G, B] values.
         * @param {number[]} color2 - An array of [R, G, B] values.
         * @returns {number} The distance between the colors.
         */
        const colorDistance = (color1, color2) => {
            return Math.sqrt(
                Math.pow(color1[0] - color2[0], 2) +
                Math.pow(color1[1] - color2[1], 2) +
                Math.pow(color1[2] - color2[2], 2)
            );
        };

        /**
         * A basic "magic wand" tool that makes similar colors transparent.
         * @param {number} x - The x-coordinate of the clicked pixel.
         * @param {number} y - The y-coordinate of the clicked pixel.
         * @param {number} tolerance - The color tolerance (0-255). Lower is more precise.
         */
        const magicWand = (x, y, tolerance) => {
            if (!imageData) {
                showMessage('Please upload an image first.', 'error');
                return;
            }

            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;

            // Get the color of the clicked pixel
            const pixelIndex = (y * width + x) * 4;
            const targetColor = [pixels[pixelIndex], pixels[pixelIndex + 1], pixels[pixelIndex + 2]];

            // Use a stack to perform a flood fill operation
            const stack = [[x, y]];
            const visited = new Set();

            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const currentPixelIndex = (cy * width + cx) * 4;

                // Check bounds and if pixel has been visited
                if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited.has(`${cx},${cy}`)) {
                    continue;
                }
                visited.add(`${cx},${cy}`);

                const currentColor = [pixels[currentPixelIndex], pixels[currentPixelIndex + 1], pixels[currentPixelIndex + 2]];

                // If the color is within the tolerance, make it transparent
                if (colorDistance(targetColor, currentColor) <= tolerance) {
                    pixels[currentPixelIndex + 3] = 0; // Set alpha to 0 (transparent)

                    // Push neighboring pixels to the stack
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            // Update the canvas with the new image data
            ctx.putImageData(imageData, 0, 0);
            showMessage('Background removed! Click another area or download.', 'success');
        };

        /**
         * The "Magic Repair" tool that restores the original background from a transparent area.
         * @param {number} x - The x-coordinate of the clicked pixel.
         * @param {number} y - The y-coordinate of the clicked pixel.
         */
        const magicRepair = (x, y) => {
            if (!imageData || !originalImageData) {
                showMessage('Please upload an image first.', 'error');
                return;
            }

            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;
            const originalPixels = originalImageData.data;

            // Check if the clicked pixel is already opaque. If so, nothing to repair.
            const pixelIndex = (y * width + x) * 4;
            if (pixels[pixelIndex + 3] !== 0) {
                showMessage('This area is not transparent.', 'error');
                return;
            }

            const stack = [[x, y]];
            const visited = new Set();

            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const currentPixelIndex = (cy * width + cx) * 4;

                if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited.has(`${cx},${cy}`)) {
                    continue;
                }
                visited.add(`${cx},${cy}`);

                // If the pixel is transparent, restore it from the original image data
                if (pixels[currentPixelIndex + 3] === 0) {
                    pixels[currentPixelIndex] = originalPixels[currentPixelIndex];
                    pixels[currentPixelIndex + 1] = originalPixels[currentPixelIndex + 1];
                    pixels[currentPixelIndex + 2] = originalPixels[currentPixelIndex + 2];
                    pixels[currentPixelIndex + 3] = 255; // Set alpha to 255 (opaque)

                    // Push neighboring pixels to the stack to continue the fill
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            ctx.putImageData(imageData, 0, 0);
            showMessage('Background restored!', 'success');
        };

        /**
         * Toggles between different editing modes and updates button styles.
         * @param {string} mode - 'magic-wand', 'magic-repair', 'manual-remove', or 'manual-repair'.
         */
        const toggleMode = (mode) => {
            currentMode = mode;
            const isManualMode = (currentMode === 'manual-remove' || currentMode === 'manual-repair');
            
            // Define all buttons that can be "active"
            const modeButtons = [magicWandBtn, magicRepairBtn, manualRemoveBtn, manualRepairBtn];
            modeButtons.forEach(btn => btn.classList.remove('bg-blue-600', 'text-white'));

            // Update button styles
            if (mode === 'magic-wand') {
                magicWandBtn.classList.add('bg-blue-600', 'text-white');
            } else if (mode === 'magic-repair') {
                magicRepairBtn.classList.add('bg-blue-600', 'text-white');
            } else if (mode === 'manual-remove') {
                manualRemoveBtn.classList.add('bg-blue-600', 'text-white');
            } else if (mode === 'manual-repair') {
                manualRepairBtn.classList.add('bg-blue-600', 'text-white');
            }

            // Show/hide manual controls and update cursor
            if (isManualMode) {
                manualControls.classList.remove('hidden');
                canvas.classList.add('manual-mode');
            } else {
                manualControls.classList.add('hidden');
                canvas.classList.remove('manual-mode');
            }

            showMessage(`Switched to ${mode} mode.`, 'success');
        };

        magicWandBtn.addEventListener('click', () => toggleMode('magic-wand'));
        magicRepairBtn.addEventListener('click', () => toggleMode('magic-repair'));
        manualRemoveBtn.addEventListener('click', () => toggleMode('manual-remove'));
        manualRepairBtn.addEventListener('click', () => toggleMode('manual-repair'));

        /**
         * Handles the canvas click event to activate the tools.
         */
        canvas.addEventListener('click', (event) => {
            // Only perform action if not in manual mode
            if (currentMode === 'manual-remove' || currentMode === 'manual-repair') {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((event.clientX - rect.left) * scaleX);
            const y = Math.floor((event.clientY - rect.top) * scaleY);
            
            if (currentMode === 'magic-wand') {
                magicWand(x, y, 32);
            } else if (currentMode === 'magic-repair') {
                magicRepair(x, y);
            }
        });

        // Event listeners for the manual brush
        canvas.addEventListener('mousedown', (e) => {
            if (currentMode !== 'manual-remove' && currentMode !== 'manual-repair') return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastPos = { 
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const newPos = { 
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
            
            if (currentMode === 'manual-remove') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(newPos.x, newPos.y, brushSize / 2, 0, Math.PI * 2, false);
                ctx.fill();
            } else if (currentMode === 'manual-repair') {
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw a circular portion of the original image onto the current canvas
                ctx.drawImage(
                    originalImage,
                    newPos.x - brushSize / 2,
                    newPos.y - brushSize / 2,
                    brushSize,
                    brushSize,
                    newPos.x - brushSize / 2,
                    newPos.y - brushSize / 2,
                    brushSize,
                    brushSize
                );
            }
            lastPos = newPos;
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Update brush size when the slider changes
        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeDisplay.textContent = brushSize;
        });

        /**
         * Handles the automatic background removal using BodyPix.
         */
        automaticRemoveBtn.addEventListener('click', async () => {
            if (!originalImage.src) {
                showMessage('Please upload an image first.', 'error');
                return;
            }
            if (!model) {
                showMessage('Model is still loading, please wait.', 'error');
                return;
            }

            // Show loading state
            automaticRemoveBtn.disabled = true;
            autoBtnText.textContent = 'Processing...';
            autoBtnSpinner.classList.remove('hidden');
            showMessage('Processing... this may take a moment.', 'success');

            // Defer the heavy processing to allow the UI to update first
            setTimeout(async () => {
                try {
                    const segmentation = await model.segmentPerson(originalImage, {
                        flipHorizontal: false,
                        internalResolution: 'high',
                        segmentationThreshold: 0.7,
                    });

                    const newImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = newImageData.data;

                    for (let i = 0; i < segmentation.data.length; i++) {
                        if (segmentation.data[i] === 0) { // 0 means background
                            data[i * 4 + 3] = 0; // Set alpha channel to 0
                        }
                    }
                    
                    ctx.putImageData(newImageData, 0, 0);
                    imageData = newImageData; // Update the main imageData variable

                    // After automatic removal, show the manual tools for touch-ups
                    magicWandBtn.classList.remove('hidden');
                    magicRepairBtn.classList.remove('hidden');
                    manualRemoveBtn.classList.remove('hidden');
                    manualRepairBtn.classList.remove('hidden');
                    toggleMode('magic-wand');

                    showMessage('Automatic background removal complete! Use the other tools for touch-ups if needed.', 'success');
                } catch (error) {
                    showMessage('Error during automatic removal. Please try again.', 'error');
                    console.error('BodyPix segmentation error:', error);
                } finally {
                    // Hide loading state
                    automaticRemoveBtn.disabled = false;
                    autoBtnText.textContent = 'Automatic Remove';
                    autoBtnSpinner.classList.add('hidden');
                }
            }, 0);
        });

        /**
         * Handles the download button click event.
         */
        downloadBtn.addEventListener('click', () => {
            if (!imageData) {
                showMessage('No image to download.', 'error');
                return;
            }

            const link = document.createElement('a');
            link.download = 'removed_background.png';
            link.href = canvas.toDataURL('image/png');

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('Image downloaded!', 'success');
        });
    </script>
</body>
</html>
